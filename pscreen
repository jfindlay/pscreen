#!/usr/bin/env python
# pscreen - manage and interface with multiple screen profiles easily
# Copyright (C) 2011  Justin Findlay
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import os,sys,re
from subprocess import call,Popen,PIPE
from argparse import ArgumentParser

# TODO:
# - make profile_dir an invocation option
# - use ansi-term for color support

profile_dir = os.path.join(os.environ['HOME'],'.config/screen/profiles')

def parse_args():
  description='manage and interface with multiple screen profiles easily'
  epilog='if no arguments are given, %(prog)s will list all available and instantiated screen profiles'
  arg_parser = ArgumentParser(description=description,epilog=epilog)
  arg_parser.add_argument('-v','--version',action='version',version='%(prog)s-0.2',help='show version')
  arg_parser.add_argument('profile',nargs='?',type=str,help='screen profile to attach')
  return arg_parser.parse_args(),arg_parser.format_usage(),arg_parser.format_help()

class Profiles:
  def __init__(self,profile_dir):
    ls = Popen(['ls',profile_dir],stdout=PIPE)
    self.profile_list = re.split('\s+',ls.stdout.read()[:-1])
    ls.stdout.close()
    self.matches = {}
  def report(self,sessions):
    if len(self.profile_list) == 0:
      return ''
    output = '[01;34m[Kavailable profiles:[m[K\n'
    for profile in self.profile_list:
      if not profile in sessions.session_list.keys():
        if profile in self.matches.keys():
          output += '\t' + self.matches[profile][0]
          output += '[01;31m[K' + self.matches[profile][1] + '[m[K'
          output += self.matches[profile][2] + '\n'
        else:
          output += '\t' + profile + '\n'
    return output
  def match(self,arg):
    match_list = []
    for profile in self.profile_list:
      match = re.search(r'^(.*)(%s)(.*)$' % sys.argv[1],profile)
      if match:
        self.matches[match.group(0)] = (match.group(1),match.group(2),match.group(3))
        match_list.append(match.group(0))
    return match_list

class Sessions:
  def __init__(self):
    screen = Popen(['screen','-ls'],stdout=PIPE)
    screen_output = re.split('\n',screen.stdout.read())[1:-3]
    screen.stdout.close()
    self.session_list = {}
    self.matches = {}
    for line in screen_output:
      match = re.search('^\s+\d+\.(\S+).+\((\w+)\)$',line)
      self.session_list[match.group(1)] = match.group(2)
  def report(self):
    if len(self.session_list) == 0:
      return ''
    output = '[01;34m[Kinstantiated profiles:[m[K\n'
    for session in self.session_list:
      if session in self.matches.keys():
        output += '\t' + self.matches[session][0]
        output += '[01;31m[K' + self.matches[session][1] + '[m[K'
        output += self.matches[session][2]
        if self.session_list[session] == 'Attached':
          output += '  [01;32m[K[%s][m[K' % self.session_list[session]
        output += '\n'
      else:
        output += '\t' + session
        if self.session_list[session] == 'Attached':
          output += '  [01;32m[K[%s][m[K' % self.session_list[session]
        output += '\n'
    return output
  def match(self,arg):
    match_list = []
    for session in self.session_list:
      match = re.search(r'^(.*)(%s)(.*)$' % sys.argv[1],session)
      if match:
        self.matches[match.group(0)] = (match.group(1),match.group(2),match.group(3))
        match_list.append(match.group(0))
    return match_list

def main():
  args,usage,help = parse_args()
  profiles = Profiles(profile_dir)
  sessions = Sessions()
  output = sessions.report() + profiles.report(sessions)

  if not args.profile:
    print output
  else:
    match_set = set(profiles.match(args.profile) + sessions.match(args.profile))
    if 0 == len(match_set):
      print 'no screen profiles in %s match %s' % (profile_dir,sys.argv[1])
    elif 1 == len(match_set):
      profile = match_set.pop()
      if profile in sessions.session_list.keys():
        call(['screen','-dr',profile])
      else:
        call(['screen','-c',os.path.join(profile_dir,profile)])
    else:
      print 'which profile do you want?\n'
      print sessions.report() + profiles.report(sessions)

if __name__ == '__main__' : main()
